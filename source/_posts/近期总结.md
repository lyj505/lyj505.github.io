---
title: 遇到的坑(1)
date: 2017-03-12 14:01:13
tags: [微信端,web前端]
categories: [ionic,angular,js]
---


# 工作中少许坑

## angularJs
### 内存 – 任务管理
1.在directive、controller里面,当页面销毁或者指令scope销毁的时候,去除定时器等代码:
  ```
//删除任何易于内存泄漏的代码。
scope.$on('$destroy', function () {
                 if (scope.modal) {
                     scope.modal.remove(); //
                 }
             });
```
2.使用directive处理复杂dom操作
<!--more-->
### 关于ng-repeat
   1.  更新滑动框（例如，用带有ng-repeat的Angular，调整它里面的元素）。
   2.  处理数据:
       1.可以通过slice处理数组。
       arrayObject.slice(start,end);返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。
       说明:请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。
       2.也可以通过ng数组自带内置函数(x in xs | limitTo: 4)。
   3.  排序:可以根据orderBy
   ```
   <ul>
    <li ng-repeat="user in users | orderBy:user.index">{{user.name}}</li>
</ul>
<!-- 根据user的index属性来排序 -->
<!-- 倒叙: -->
<ul>
    <li ng-repeat="user in users | orderBy:user.index:'desc'">{{user.name}}</li>
</ul>
<!-- 或者 -->
<ul>
    <li ng-repeat="user in users | orderBy:-user.index">{{user.name}}</li>
</ul>
   ```
   4.根据索引循环变量
   有时候遇到报错:'Error: [ngRepeat:dupes]',ngRepeat不允许collection中存在两个相同Id的对象。
   处理方法:
   ```
   item in items track by item.id。
   //也可以直接拿循环的索引变量$index来用item
   item in items track by $index
   ```

### AngularJS使用 ng-disabled
 在controller 中增加一个方法
 disableButton()
 ng-disabled 会watch页面上指定的元素内容 根绝表单的填写情况来重置提交button 的可用性及其变化颜色。
### angular请求缓存
 $http.get(url, {cache: false}).====》不从缓存中读取 请求。
{cache: true}告诉$http service要在$http的默认缓存中缓存特定的请求响应结果
 要根据实际需求来设置请求的cache。

### ng-if 和 ng-show
 A common case when this difference is significant is when using css selectors that rely on an element's position within the DOM, such as the :first-child or:last-child pseudo-classes.
  1.ng-if 和ng-show 与ngHide 的不同处是ng-if 完全congdom中删除了,
需要重新创建一个dom元素,而不是和它们一样只是控制元素的css visibility 属性。
ng-if会移除dom，生成dom，而ng-show只是改变其display属性(应该是visibility属性。。)
所以通过ng-show 可以创建动画。。控制display 这么说
  2.在初始化页面的时候ng-show 会出现闪现。一般使用ng-if。
  3.ng-if会影响并阻断scope绑定值，ngshow不会，建议：div里面有很多其他指令
  如ng-model的尽量使用ng-show，单个独立的可以使用ng-if。

### 指令
指令3种符号的代表
& 方法  =====》在指令中,用来继承使用父作用域对应的方法。
@ 属性  =====》在指令中,用来继承使用父作用域对应的属性。
= 双向绑定  =====》在指令中,双向绑定变量,在指令中可以读取或改变变量的值,在父作用域也会发生相应的变化。
attrs 这个蛮好用的,可以根据封装指定属性,控制属性值,做出可用性强的指令组件。

link compile 阶段。。---指令形成阶段。。。=============？？？？？？
controller app.js directive 的形成阶段。。。============？？？？？？

### 执行顺序
[可以参考下这篇文章理解](https://my.oschina.net/brant/blog/419641)
补充一点就是,angular加载对应页面时,会先加载控制器的内容,所以初始化变量,可以选择再控制器中初始化,
如有需求,在指令中改变值。
### 指令执行顺序
指令的执行分两个阶段，一个是compile，一个是link。

link方法一般用来对元素进行处理。这里是对元素进行事件的绑定。当用户元素div进行点击时，会弹出鼠标点击的框。
当页面加载进来时，自定义的link不会弹出来。意思就是说，当存在compile时，不会执行你自定义的link函数，
因为angular会把compile返回的函数当做link函数来执行。当不存在compile时，就会执行你自定义的link函数。
compile函数很少被用到，写起来比较麻烦。
compile函数的作用是对指令的模板进行转换，compile函数就把指令的模板进行了叠加，
改变了页面上的DOM结构。
link函数的作用是在模型和视图之间建立关联，同时在元素上绑定事件监听。
scope在链接阶段才会被绑定到元素上，因此在compile中操作scope会报错。

### ionic 复制文本问题
  在容器上增加这个类
```
.selectable {
    -webkit-user-select: auto;
}
<!-- 电脑端可以复制文字了。。 -->
```

## ionic
### ionic 右滑删除
```
<ion-list>
            <ion-item  class="item item-thumbnail-left shop-car-item " ng-repeat="item in shopCar.items">
                <ion-option-button class="button-assertive"
                                   ng-click="Delete(item)">
                    删除
                </ion-option-button>
            </ion-item >
            </ion-list>
```
注:在Delete 方法里面绑定删除的方法。。。

### 移动端分页原理:ionic
1.用户往下滑动刷新。
```
<!-- html::::
当用户到达页脚或页脚附近时，ionInfiniteScroll指令允许你调用一个函数 。
当用户滚动的距离超出底部的内容时，就会触发你指定的on-infinite。
ng-if就可以用一个简单的方法阻止无限滚动
 icon="ion-loading-c" 当加载时显示的图标。默认: 'ion-loading-d'。
-->
  <ion-infinite-scroll
                ng-if="more"
                on-infinite="loadNext()"
                distance="1%">
        </ion-infinite-scroll>
        <!-- 在controller里控制more的值:::::::: -->
   function loadNext(){
   <!-- 业务逻辑 每执行一次loadNext,对应的page增加1-->
   $scope.limit = 10;
   $scope.page + 1;
   $scope.more = canBeLoaded();
   }


   function canBeLoaded(){
        return ($scope.page * $scope.limit < $scope.total);
        //阻止无限滚动,当前页数*每页限制数量小于当前查询条件下的总量的时候,
        就可以继续往下滚动,出发查询事件
        //当前页数*每页限制数量大于当前查询条件下的总量的时候,//即不需要滑动了,则返回一个false,阻止滑动。
   }

```
2.在最下方有个"加载更多"的按钮,手动点击触发刷新事件。
其实就是不使用ionic封装的'ion-infinite-scroll'指令,在顶部手动添加一个元素,根据能否出现加载更多来展示按钮
```
<!-- 当总量小于当前页数*每页限制,说明已经显示完毕了 -->
 <div ng-if="total > page* limit">
      <div class="button" ng-click="loadNext()">加载更多</div>
 </div>
```

## 微信相关

### 微信授权登录:
1.静默授权。 ====================？
2.获取用户信息授权。================？


### angular SPA单页应用 微信支付时的坑

在前端页面调用微信支付时候,使用ios微信操作时,报"当前页面的URL未注册",Android正常。
经过测试,对于业务来说,因为支付页面需要通过不同的支付id进入不同的支付页面,所以当,ios操作时,
虽然路由发生了变化,但是在微信浏览器里没有识别出原先配置好的支付地址,而android机能够识别。

当时使用了一个很不友好的方法,解决问题:当进入支付页面controller的时候主动的执行"window.location.reload();",
刷新一次页面...ios就能够正确地识别支付URL。
当然后面可以去掉 angular应用中的'#',也可以解决这个问题。支付未能正确识别,最终还是URL的问题。

### 微信授权

1、以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权并自动跳转到回调页的。用户感知的就是直接进入了回调页（往往是业务页面）
2、以snsapi_userinfo为scope发起的网页授权，是用来获取用户的基本信息的。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。
3、用户管理类接口中的“获取用户基本信息接口”，是在用户和公众号产生消息交互或关注后事件推送后，才能根据用户OpenID来获取用户基本信息。这个接口，包括其他微信接口，都是需要该用户（即openid）关注了公众号后，才能调用成功的。

### 解决页面回调问题
经过微信回调后URL变成:
'//http://xxxx.com/xxx/?code=0031J8QD06l2Vf2BMQRD0GX5QD01J8Qs&state=money#/me/xxxx'
通过angular的方法是取不出来的('$stateParams.code'),因为该方法只能取警号之后的参数。
使用:
```
  var curHref = window.location.href;
        var codeValue = curHref.substring(curHref.indexOf("code="),curHref.indexOf("&"));
        codeValue = codeValue.substring(codeValue.indexOf("=")+1,codeValue.length);
```

## 单位
数据库存的是分
给用户显示的需要*100 转化成 元。(根据实际需求去封装一个可用性函数);

 规定时间:
```
   var   beginTime = '2016-12-09 15:00:00';

   var   endTime = '2016-12-14 23:59:59';
```
关于数据,如果不清楚后台返回的数据库组成,则每次判断一下是否为空,再赋值,不然会报错,该属性不存在。

## localstorage

```
//存对应key进本地存储
 function saveLocalStorage(key, obj) {
    if (window.localStorage) {
        window.localStorage.setItem(key, (typeof obj === 'string') ? obj : JSON.stringify(obj));
    }
};

//获取本地本地存储数据
 function getLocalStorage(key) {
    if (window.localStorage) {
        return window.localStorage.getItem(key);
    } else {
        return null;
    }
};
//清空本地某个key对应的本地存储数据
function removeLocalStorage(key){
localStorage.removeItem(key);
}
//批量删除所有本地存储数据
 function ClearAllLocalStorage(){
 localStorage.clear();
 }
```



## 常用JS 工具/类


## 习惯用好TODO,常用代码好习惯
[可以参考下这篇文章理解](http://codeguide.bootcss.com/#html-syntax)
